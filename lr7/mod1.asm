;сегмент стеку
stk     segment stack
	db	     256 dup (?)
stk     ends

;сегмент даних
data	     segment para public 'data'
	msgPrompt1	     db	     'A	[ $'
	msgPrompt2	     db	     ' ] = $'

data	     ends

	public outString
	public outPrompt
	public convertStrToInt
	public printInt
;сегмент команд
code    segment para public 'code'
assume  cs:code, ds:data, ss:stk


;-------------------------------------------------------------------------------
;процедура виведення рядка символів, обмежених+ символом '$' на консоль
;вхід:	DX - адреса рядка
;-------------------------------------------------------------------------------
outString	     proc near
	mov     ah, 09h
	int     21h
	ret
outString	     endp
;-------------------------------------------------------------------------------
;процедура виведення на консоль	імені масиву та індексу елемента
;-------------------------------------------------------------------------------
proc near
	lea     dx, msgPrompt1	     ;виведення імені масиву
	call    outString
	mov     ax, si			     ;AX = індекс елементу масиву
	call    printInt		     ;виведення індексу
	lea     dx, msgPrompt2
	call    outString
	ret
outPrompt	     endp
;-------------------------------------------------------------------------------
;процедура перетворення рядка в	число зі знаком в форматі слова
;(діапазон	значення числа від -32768 до 32767)
;вхід:	 DX - адреса буфера
;вихід: AX - число в форматі слова (в разі помилки AX =	0)
;CF	= 1 - помилка
;-------------------------------------------------------------------------------
convertStrToInt proc near
;збереження регістрів
	push    bx
	push    cx
	push    dx
	push    si
	push    di
	push    bp
	mov     si, dx			     ;SI - адреса буфера
	xor     cx, cx
	mov     cl, [si + 1]	     ;CL = довжина введеного рядка
;перевірка знаку числа
	add     si, 2			     ;SI - адреса рядка
	mov     bl, [si]			 ;BL = перший символ рядка
	cmp     bl, '-'			     ;порівняння першого символу з '-'
	jne     mNoSign			     ;якщо не '-', то перетворюємо рядок як число без	знаку
	inc     si					 ;інкремент адреси рядка
	dec     cl					 ;декремент довжини рядка
;перетворення рядка у слово	без знаку
mNoSign:
	mov     bp, bx			     ;зберігаємо регістр
	xor     bx, bx
	mov     di, 10			     ;DI = множник 10 (база системи числення)
	xor     ax, ax			     ;AX = 0, для обчислення, яке	введене з клавіатури
mScanString:
	mov     bl, [si]			 ;завантаження в BL чергового	символу рядка
	inc     si					 ;інкремент адреси
	cmp     bl, '0'			     ;якщо код символу менше коду '0'
	jb	     mErrorValue		 ;повертаємо помилку
	cmp     bl, '9'			     ;якщо код символу більше коду '9'
	ja	     mErrorValue		 ;повертаємо помилку
	sub     bl, '0'			     ;перетворення + символу-цифри в число
	mul     di					 ;AX = AX *	10
	jc	     mErrorValue		 ;якщо результат більше 16  бітів - помилка
	add     ax, bx			     ;додаємо цифру
	jc	     mErrorValue		 ;якщо переповнення	- помилка
	loop     mScanString	     ;продовжуємо сканувати	рядок
;обробка знаку	числа та	перевірка діапазону для від'ємного числа
	mov     bx, bp			     ;відновлюємо регістр
	cmp     bl, '-'			     ;знову перевіряємо	знак
	jne     mPlus			     ;якщо перший символ не '-', то число додатне
	cmp     ax, 32768			 ;модуль від'ємного числа повинен бути не більш 32768
	ja	    mErrorValue		     ;якщо більше (без знаку), повертаємо помилку
	neg     ax					 ;інвертуємо число(число - від'ємне)
	jmp     mOk				     ;переходимо до	нормального завершення процедури
;перевірка діапазону для додатного числа
mPlus:
	cmp     ax, 32767			 ;додатне число	повинно	 бути не більше	32767
	ja	     mErrorValue		 ;якщо більше, повертаємо помилку
;успішне перетворення рядка у число в форматі слова
mOk:
	clc				     		 ;CF = 0 ознака успішного перетворення рядка у число
	jmp     mExit			     ;переходимо до	виходу з процедури

;помилка перетворення рядка у число в форматі слова
mErrorValue:
	xor     ax, ax			     ;AX = 0
	stc					     	 ;CF = 1 повертаємо помилку
mExit:
;відновлення регістрів
	pop     bp
	pop     di
	pop     si
	pop     dx
	pop     cx
	pop     bx
	ret
convertStrToInt endp
;-------------------------------------------------------------------------------
;процедура виведення цілого числа у форматі слова на консоль
;вхід:	AX - ціле число
;-------------------------------------------------------------------------------
printInt	     proc near
;збереження регістрів
	push    ax
	push    bx
	push    cx
	push    dx
;обробка знаку	числа AX
	cmp     ax, 0		     ;якщо число додатне
	jge     mPositive		 ;перехід до його обробки
	neg     ax				 ;інакше - перетворення від'ємного числа на додатне
	push    ax
	mov     dl, '-'		     ;виведення на консоль
	mov     ah, 02h		     ;знаку '-'
	int     21h
	pop     ax

;обробка додатного	числа
mPositive:
	mov     bx, 10
	xor     cx, cx		     ;лічильник цифр числа

;отримуємо цифри числа AX
mDivisionNumber:
	cwd
	div     bx				 ;ділимо з остачею
	push    dx			     ;зберігаємо остачу	в стеку
	inc     cx				 ;збільшуємо лічильник цифр числа
	or	     ax, ax		     ;якщо число ще не 0,
	jnz     mDivisionNumber  ;продовжуємо цикл
;виведення на консоль цифр числа AX
mPrintChar:
	pop     dx				 ;DX = цифра числа
	add     dl, 30h		     ;DL = символ	цифри числа
	mov     ah, 02h		     ;виведення символу-цифри на консоль
	int     21h
	loop    mPrintChar	     ;лічильник цифр числа не 0 - продовжуємо цикл
;відновлення регістрів
	pop     dx
	pop     cx
	pop     bx
	pop     ax
	ret
printInt	     endp
;-------------------------------------------------------------------------------
code    ends
	end
